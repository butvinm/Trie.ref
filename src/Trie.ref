/*
Naming conventions:
Rxx - related to the root of the trie
Sxx - related to the child of the root (S - stands for "sub")
xx - related to the new node (which we currently inserting/looking for)

Eow - end of word
*/

*$FROM LibraryEx
$EXTERN Map, Reduce, Apply, UnBracket;


$EENUM TrieType;
$EENUM Trie;


/* Type constructor for the polymorphic trie.

To not pass a compare function everywhere, we adopt Zig approach and define type constructor to create a trie type with associated compare function.
*/
$ENTRY TrieType-Init {
  t.Cmp
    = t.Cmp : e.Self
    = [TrieType
      (Empty <EmptyImpl e.Self>)
      (Build <BuildImpl e.Self>)
      (Insert <InsertImpl e.Self>)
      (Delete <DeleteImpl e.Self>)
      (Show <ShowImpl e.Self>)
    ];
}


EmptyImpl {
  e.Self = [Trie Root /* empty */];
}


InsertImpl {
  t.Cmp = {
    [Trie t.RChar e.RChildren [Trie Eow]]
    /* empty */
      = [Trie t.RChar e.RChildren [Trie Eow]];

    [Trie t.RChar e.RChildren]
    /* empty */
      = [Trie t.RChar e.RChildren [Trie Eow]];

    [Trie t.RChar e.RChildrenB [Trie t.Char e.SChildren] e.RChildrenE]
    t.Char e.Rest
      = <<InsertImpl t.Cmp> [Trie t.Char e.SChildren] e.Rest> : t.NewChild
      = [Trie t.RChar e.RChildrenB t.NewChild e.RChildrenE];

    [Trie t.RChar e.RChildren]
    t.Char e.Rest
      = <<InsertImpl t.Cmp> [Trie t.Char /* empty */] e.Rest> : t.NewChild
      = <AddChildOrdered t.Cmp t.NewChild e.RChildren> : e.RChildren^
      = [Trie t.RChar e.RChildren];
  };
}


AddChildOrdered {
  t.Cmp t.Child /* empty */ = t.Child;

  t.Cmp [Trie t.Char e.Children] [Trie t.SChar e.SChildren] e.Rest
    = <CompleteCmp t.Cmp> : t.Cmp^
    = <Apply t.Cmp t.Char t.SChar> : {
      '-' = [Trie t.Char e.Children] [Trie t.SChar e.SChildren] e.Rest;
      '+' = [Trie t.SChar e.SChildren] <AddChildOrdered t.Cmp [Trie t.Char e.Children] e.Rest>;
      '0' = <Prout 'For whatever reason two tries with the same char were compared what essentially should not happen'> <Exit 69>;
    };
}


CompleteCmp {
  t.Cmp = {
    t.Obj Eow = '-';
    Eow t.Obj = '+';
    t.Obj Root = '+';
    Root t.Obj = '-';
    t.Obj t.Other = <Apply t.Cmp t.Obj t.Other>;
  };
}


BuildImpl {
  e.Self = {
    e.Words = <Reduce
      { t.Trie (e.Word) = <<InsertImpl e.Self> t.Trie e.Word> }
      [Trie Root /* empty */]
      e.Words
    >
  };
}


ShowImpl {
  e.Self = {
    e.Indent [Trie t.Char /* empty */ ] = e.Indent t.Char '\n';

    e.Indent [Trie t.Char e.Children ]
      = e.Indent t.Char '\n' <Map (&ShowImpl e.Indent '  ') e.Children>;
  };
}


DeleteImpl {
  e.Self = {
    [Trie t.RChar e.RChildren [Trie Eow]]
    /* empty */
      = Success [Trie t.RChar e.RChildren];

    [Trie t.RChar e.RChildrenB [Trie t.Char e.SChildren] e.RChildrenE]
    t.Char e.Rest
      = <<DeleteImpl e.Self> [Trie t.Char e.SChildren] e.Rest> : {
        Success [Trie t.Char /* empty */] = Success [Trie t.RChar e.RChildrenB e.RChildrenE];
        Success t.Child = Success [Trie t.RChar e.RChildrenB t.Child e.RChildrenE];
        Fail e.Error = Fail e.Error;
      };

    t.Trie e.Word
      = Fail 'Word "' e.Word '" not found in the trie';
  };
}
