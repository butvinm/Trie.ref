/*
Naming conventions:
Rxx - related to the root of the trie
Sxx - related to the child of the root (S - stands for "sub")
xx - related to the new node (which we currently inserting/looking for)

Eow - end of word
*/

*$FROM LibraryEx
$EXTERN Map, Reduce, Apply, UnBracket;


$EENUM TrieType;
$EENUM Trie;


/* Type constructor for the polymorphic trie.

To not pass a compare function everywhere, we adopt Zig approach and define type constructor to create a trie type with associated compare function.
*/
$ENTRY TrieType-Init {
  t.Cmp
    = <CompleteCmp t.Cmp> : t.Cmp^
    = [TrieType
      (Empty <EmptyImpl t.Cmp>)
      (Build <BuildImpl t.Cmp>)
      (Insert <InsertImpl t.Cmp>)
      (Merge <MergeImpl t.Cmp>)
      (Delete <DeleteImpl t.Cmp>)
      (Lookup <LookupImpl t.Cmp>)
      (Show <ShowImpl t.Cmp>)
    ];
}


EmptyImpl {
  e.Self = [Trie Root /* empty */];
}


InsertImpl {
  t.Cmp = {
    [Trie t.RChar e.RChildren [Trie Eow]]
    /* empty */
      = [Trie t.RChar e.RChildren [Trie Eow]];

    [Trie t.RChar e.RChildren]
    /* empty */
      = [Trie t.RChar e.RChildren [Trie Eow]];

    [Trie t.RChar e.RChildrenB [Trie t.Char e.SChildren] e.RChildrenE]
    t.Char e.Rest
      = <<InsertImpl t.Cmp> [Trie t.Char e.SChildren] e.Rest> : t.NewChild
      = [Trie t.RChar e.RChildrenB t.NewChild e.RChildrenE];

    [Trie t.RChar e.RChildren]
    t.Char e.Rest
      = <<InsertImpl t.Cmp> [Trie t.Char /* empty */] e.Rest> : t.NewChild
      = [Trie t.RChar <SortChildren t.Cmp t.NewChild e.RChildren>];
  };
}


SortChildren {
  t.Cmp /* empty */ = /* empty */;

  t.Cmp t.Child = t.Child;

  t.Cmp [Trie t.Char e.Children] e.Rest
    = <Reduce
      {
        (e.Acc) [Trie t.SChar e.SChildren], <Apply t.Cmp t.SChar t.Char> : '-' = (e.Acc [Trie t.SChar e.SChildren]);
        (e.Acc) t.Child = (e.Acc);
      }
      ()
      e.Rest
    > : (e.Smaller)
    = <Reduce
      {
        (e.Acc) [Trie t.SChar e.SChildren], <Apply t.Cmp t.SChar t.Char> : '-' = (e.Acc);
        (e.Acc) t.Child = (e.Acc t.Child);
      }
      ()
      e.Rest
    > : (e.Bigger)
    = <SortChildren t.Cmp e.Smaller> [Trie t.Char e.Children] <SortChildren t.Cmp e.Bigger>;
}


CompleteCmp {
  t.Cmp = {
    t.Obj Eow = '-';
    Eow t.Obj = '+';
    t.Obj Root = '+';
    Root t.Obj = '-';
    t.Obj t.Other = <Apply t.Cmp t.Obj t.Other>;
  };
}


BuildImpl {
  e.Self = {
    e.Words = <Reduce
      { t.Trie (e.Word) = <<InsertImpl e.Self> t.Trie e.Word> }
      [Trie Root /* empty */]
      e.Words
    >
  };
}


ShowImpl {
  e.Self = {
    e.Indent [Trie t.Char /* empty */ ] = e.Indent t.Char '\n';

    e.Indent [Trie t.Char e.Children ]
      = e.Indent t.Char '\n' <Map (&ShowImpl e.Indent '  ') e.Children>;
  };
}


DeleteImpl {
  e.Self = {
    [Trie t.RChar e.RChildren [Trie Eow]]
    /* empty */
      = Success [Trie t.RChar e.RChildren];

    [Trie t.RChar e.RChildrenB [Trie t.Char e.SChildren] e.RChildrenE]
    t.Char e.Rest
      = <<DeleteImpl e.Self> [Trie t.Char e.SChildren] e.Rest> : {
        Success [Trie t.Char /* empty */] = Success [Trie t.RChar e.RChildrenB e.RChildrenE];
        Success t.Child = Success [Trie t.RChar e.RChildrenB t.Child e.RChildrenE];
        Fail e.Error = Fail e.Error;
      };

    t.Trie e.Word
      = Fail 'Word "' e.Word '" not found in the trie';
  };
}


LookupImpl {
  e.Self = {
    [Trie t.RChar e.RChildren [Trie Eow]]
    /* empty */
      = True;

    [Trie t.RChar e.RChildrenB [Trie t.Char e.SChildren] e.RChildrenE]
    t.Char e.Rest
      = <<LookupImpl e.Self> [Trie t.Char e.SChildren] e.Rest>;

    t.Trie e.Word = False;
  };
}


MergeImpl {
  t.Cmp = {
    [Trie t.Char e.Children0] [Trie t.Char e.Children1]
      = [Trie t.Char <MergeChildren t.Cmp (e.Children0) (e.Children1)>]
  };
}


MergeChildren {
  t.Cmp
  (/* empty */)
  (e.Children)
    = e.Children;

  t.Cmp
  (e.Children)
  (/* empty */)
    = e.Children;

  t.Cmp
  (e.Children0B [Trie t.Char e.SChildren0] e.Children0E)
  (e.Children1B [Trie t.Char e.SChildren1] e.Children1E)
    = <<MergeImpl t.Cmp> [Trie t.Char e.SChildren0] [Trie t.Char e.SChildren1]> : t.Child
    = <MergeChildren t.Cmp (e.Children0B e.Children0E) (e.Children1B e.Children1E)> : e.Children
    = <SortChildren t.Cmp t.Child e.Children>;

  t.Cmp
  (e.Children0)
  (e.Children1)
    = <SortChildren t.Cmp e.Children0 e.Children1>;
}
